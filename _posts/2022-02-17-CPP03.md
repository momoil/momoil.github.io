---
layout: post
title: "C++入门03"
date: 2022-02-17
tags: [C++]
comments: true
author: momo
---

C++入门03

<!-- more -->
# 开始 #

*本博客为本人复习笔记，不是教程；*
----------
# 1.new 运算符 #

----------
- 在堆区开辟的数据；
- 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收；
- 在C++中主要利用new在堆区开辟内存；

> //利用new关键字可以将数据开辟到堆区
> 
> //指针本质也是局部变量，放在栈上，指针保存的数据是放在堆区
> 
> int * p = new int(10);//创建变量
> 
> int * arr = new int[10];//创建数组，10代表数组中有10个元素
> 
> deletel[] arr; //释放内存
> deletel p；//释放内存

- C++中利用new操作符在堆区开辟数据
- 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符deletel
- 语法:new数据类型
- 利用new创建的数据，会返回该数据对应的类型的指针

# 2.引用 #

----------

## 2.1引用的基本使用 ##

- 作用:给变是起别名
- 语法:数据类型 &别名 = 原名

- 备注：引用必须初始化； 
- 引用初始化之后就不可以改变了；



>     int a = 10；
>     int &b = a；
>     //a和b操作的是同一块内存；

引用的本质，就是指针常量；

# 3.函数重载 #
## 3.1 概述 ##

作用:函数名可以相同，提高复用性

函数重载满足条件:

- 同一个作用域下
- 函数名称相同
- 函数参数 类型不同 或者个数不同 或者顺序不同

注意:函数的返回值不可以作为函数重载的条件

# 4.类和对象 #
## 4.1 封装 ##
- 封装是C++面向对象三大特性之一封装的意义:
- 将属性和行为作为一个整体，表现生活中的事物
- 将属性和行为加以权限控制

- 封装意义—:
- 在设计类的时候,属性和行为写在一起，表现事物
- 语法:
- class类名 {访问权限:属性{行为}}

>     #include <iostream>
>     #include <string>
>     using namespace std;
>     //设计一个圆类，求圆的周长
>     //圆的周长公式：2*PI*半径
>     const double PI = 3.14;
>     class Circle
>     {
>     	//访问权限
>     public:
> 	    //属性
> 	    int m_r;	//半径
> 	    //行为
> 	    //获取圆的周长
> 	    double calculateZC()
> 	    {
> 	    return 2 * PI * m_r;
> 	    }
>     };
>     int main()
>     {
> 	    //通过圆类，创建具体的圆(对象)
> 	    Circle c1;
> 	    //给圆对象的属性进行赋值操作
> 	    c1.m_r = 10;
> 	    cout << "圆的周长为：" << c1.calculateZC() << endl;
>     	system("pause");
>     
>     	return 0;
>     }

封装意义二:

类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种:

1. public		公共权限
2. protected	保护权限
3. private		私有权限

>     //public:       公共权限    成员类内可以访问到,类外也可以访问,子类也可以访问
>     //protected:    保护权限    成员类内可以访问到,类外不可以访问,子类也可以访问
>     //private:      私有权限    成员类内可以访问到,类外不可以访问,子类不可以访问

- struct和class区别
- struct 默认权限是公共pub1ic
- class默认权限是私有private

## 4.2对象的初始化和清理 ##

4.2.1构造函数和析构函数

对象的初始化和清理也是两个非常重要的安全问题

- 一个对象或者变是没有初始状态，对其使用后果是未知
- 同样的使用完一个对象或变呈，没有及时清理，也会造成一定的安全问题

C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现。

- 构造函数:主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
- 析构函数:主要作用在于对象销毁前系统自动调用，执行一些清理工作。

构造函数语法:类名(){}
1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用—次

析构函数语法:~类名(){}
1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在销毁前白动调用析构函数，无须手动调用.而日只佘调用—次

- 构造和析构都是必须有的实现,如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现。


>     #include <iostream>
>     #include <string>
>     using namespace std;
>     class Person
>     {
>     public:
>       int m_a;
>       int m_b;
>     	//构造函数
>     	Person() ：m_a(10),m_b(20) //初始化列表
>     	{
>     		cout << "构造函数的调用" << endl;
>     	}
>     	//析构函数
>     	~Person() 
>     	{
>     		cout << "析构函数的调用" << endl;
>     	}
>     
>     }; 
>     void test01() 
>     {
>     	Person P;//在栈上的数据，test01执行完毕后，释放这个对象
>     }
>     int main()
>     {
>     	test01();
>     	system("pause");
>     
>     	return 0;
>     }
>     

## 静态成员函数 ##

- 静态成员函数
- 所有对象共享同一个函数
- 静态成员函数只能访问静态成员变量


>     
>     class Person
>     {
>     public:
>     	//静态成员函数
>     	static void func() 
>     	{
>     	    m_A = 100;//静态成员函数只能访问静态成员变量
>     		cout << "func函数的调用" << endl;
>     	}
>     		static int m_A;
>     		int m_B = 10;
>     };
>     
>     void test01() 
>     {
>     	Person P;//在栈上的数据，test01执行完毕后，释放这个对象
>     }
>     int main()
>     {
>     	//第一种调用方法
>     	Person p;
>     	p.func();
>     	//第二种调用方法
>     	Person::func();
>     
>     	system("pause");
>     	return 0;
>     }
>     
## this指针 ##

- 解决名称冲突
- 返回对象本身用*this




